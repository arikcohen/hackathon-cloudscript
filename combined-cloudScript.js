function GetEntityToken(params, context) {
    var getTokenRequest = {};
    var getTokenResponse = entity.GetEntityToken(getTokenRequest);
    var entityId = getTokenResponse.Entity.Id;
    var entityType = getTokenResponse.Entity.Type;
}
handlers.GetEntityToken = GetEntityToken;
function GetObjects(params, context) {
    var getObjRequest = {
        Entity: {
            Id: params.entityId,
            Type: params.entityType
        }
    };
    var getObjResponse = entity.GetObjects(getObjRequest);
    var entityId = getObjResponse.Entity.Id;
    var entityType = getObjResponse.Entity.Type;
    var entityObjs = getObjResponse.Objects["testKey"];
}
handlers.GetObjects = GetObjects;
// This is a Cloud Script function. "args" is set to the value of the "FunctionParameter" 
// parameter of the ExecuteCloudScript API.
// (https://api.playfab.com/Documentation/Client/method/ExecuteCloudScript)
// "context" contains additional information when the Cloud Script function is called from a PlayStream action.
var AuthenticationHelloWorld = function (args, context) {
    // The pre-defined "currentPlayerId" variable is initialized to the PlayFab ID of the player logged-in on the game client. 
    // Cloud Script handles authenticating the player automatically.
    var message = "Hello " + currentPlayerId + "!";
    // You can use the "log" object to write out debugging statements. It has
    // three functions corresponding to logging level: debug, info, and error. These functions
    // take a message string and an optional object.
    log.info(message);
    var inputValue = null;
    if (args && args.inputValue)
        inputValue = args.inputValue;
    log.debug("helloWorld:", { input: args.inputValue });
    // The value you return from a Cloud Script function is passed back 
    // to the game client in the ExecuteCloudScript API response, along with any log statements
    // and additional diagnostic information, such as any errors returned by API calls or external HTTP
    // requests. They are also included in the optional player_executed_cloudscript PlayStream event 
    // generated by the function execution.
    // (https://api.playfab.com/playstream/docs/PlayStreamEventModels/player/player_executed_cloudscript)
    return { messageValue: message };
};
handlers["AuthenticationHelloWorld"] = AuthenticationHelloWorld;
handlers.craftItem = function (args, context) {
    var message = "Crafting initiated by" + currentPlayerId;
    log.info(message);
    //Inventory item to Craft
    //todo: Hardcoded for now - want to input this
    var item_To_Craft = "Crafted_Wand";
    //Currency costs to crafted item
    var craftCostinGold = 0;
    var craftCostinWood = 0;
    //Grabbing Catalog
    var getCatalogItemsResponse = server.GetCatalogItems({ CatalogVersion: null });
    var catalogItems = getCatalogItemsResponse.Catalog;
    var length = catalogItems.length;
    var catalogItemInstance;
    for (var i = 0; i <= length; i++) {
        if ((catalogItems[i].ItemId.toString()) == item_To_Craft) //itemId being the item id of the item we are granting (these are all unique in the catalog). Note: I tried JSON.parse(catalogItems[i]) and got errors.
         {
            //assign crafting item to catalog item
            catalogItemInstance = catalogItems[i];
        }
        else {
            var result = "Cannot locate " + item_To_Craft + " in the catalog";
            return { rewards: result };
        }
    }
    //Player Data 
    var inventory = server.GetUserInventory({ PlayFabId: currentPlayerId });
    //subtract currencies
    server.SubtractUserVirtualCurrency({ PlayFabId: currentPlayerId, VirtualCurrency: "GD", Amount: craftCostinGold });
    server.SubtractUserVirtualCurrency({ PlayFabId: currentPlayerId, VirtualCurrency: "WD", Amount: craftCostinWood });
    //Add Craft item to inventory
    var itemGrantResult = server.GrantItemsToUser({
        PlayFabId: currentPlayerId,
        Annotation: "Given for crafting",
        ItemIds: [item_To_Craft]
    });
    var resultItems = itemGrantResult.ItemGrantResults;
    return { rewards: resultItems };
};
// This function will control the game's reward heartbeat and is called by a scheduled task
var DailyRewardUpdateLastRewardHeartbeat = function (args, context) {
    var message = "Executing the DailyReward heartbeat - all players will now be able to claim their next reward ";
    log.info(message);
    var headers = {};
    var body = {};
    var url = "http://worldclockapi.com/api/json/utc/now";
    var content = JSON.stringify(body);
    var httpMethod = "get";
    var contentType = "application/json";
    // The pre-defined http object makes synchronous HTTP requests
    var timeResponse = JSON.parse(http.request(url, httpMethod, content, contentType, headers));
    var currentDateTime = new Date(timeResponse.currentDateTime);
    log.debug(currentDateTime.toDateString());
    // Update the title data value to contain current datetime
    server.SetTitleInternalData({
        "Key": "DailyRewardLastRewardHeartbeat",
        "Value": JSON.stringify(currentDateTime.getTime())
    });
    return { messageValue: message };
};
handlers["DailyRewardUpdateLastRewardHeartbeat"] = DailyRewardUpdateLastRewardHeartbeat;
// This function checks to see how much longer a player must wait to claim theiir next reward
var DailyRewardsCheckRewardAvailability = function (args, context) {
    var message = "Checking whether " + currentPlayerId + " can claim a reward";
    log.info(message);
    var headers = {};
    var body = {};
    var url = "http://worldclockapi.com/api/json/utc/now";
    var content = JSON.stringify(body);
    var httpMethod = "get";
    var contentType = "application/json";
    // Get the current time - the pre-defined http object makes synchronous HTTP requests
    var timeResponse = JSON.parse(http.request(url, httpMethod, content, contentType, headers));
    var currentDateTime = new Date(timeResponse.currentDateTime);
    log.info("Player " + currentPlayerId + " is checking at time " + currentDateTime.toTimeString());
    // Get the title's last reward heartbeat time
    var internalData = server.GetTitleInternalData({}).Data;
    var titleLastRewardHeartbeat = internalData.DailyRewardLastRewardHeartbeat;
    var rewardCycleLengthInMS = parseInt(internalData.DailyRewardDelayTimeInMinutes) * 60 * 1000;
    var nextHeartbeat = parseInt(titleLastRewardHeartbeat) + rewardCycleLengthInMS;
    var nextHeartbeatDate = new Date(nextHeartbeat);
    // Get the player's last reward claim time
    var userData = server.GetUserReadOnlyData({ PlayFabId: currentPlayerId, Keys: ["DailyRewardClaimed", "DailyRewardStreak"] });
    var playerLastRewardClaimed = userData.Data["DailyRewardClaimed"].Value;
    var playerRewardStreak = parseInt(userData.Data["DailyRewardStreak"].Value);
    var playerLastRewardClaimedDate = new Date(parseInt(playerLastRewardClaimed));
    // Verify the player is eligible for a new daily reward
    if (playerLastRewardClaimed > titleLastRewardHeartbeat) {
        message = "The player " + currentPlayerId + " was NOT YET eligible for a new reward. Wait for the next title reward heartbeat";
        log.info(message);
    }
    else {
        message = "The player " + currentPlayerId + "IS ELIGIBLE for a new reward.";
        log.info(message);
    }
    return { messageValue: message };
};
handlers["DailyRewardsCheckRewardAvailability"] = DailyRewardsCheckRewardAvailability;
// This function attempts to redeem a the next daily reward for a player
// Triggered by a button press by the player
var DailyRewardsTryClaimReward = function (args, context) {
    var DAILY_REWARD_CYCLE = [
        "DailyReward_Day1", "DailyReward_Day2", "DailyReward_Day3", "DailyReward_Day4", "DailyReward_Day5", "DailyRewardTable"
    ];
    var rewardResult = {
        playerRewardStreak: "error",
        playerLastRewardDate: "error",
        playerLastReward: "error",
        titleNextRewardDate: "error"
    };
    var message = "Player " + currentPlayerId + " is trying to claim a reward";
    log.info(message);
    var headers = {};
    var body = {};
    var url = "http://worldclockapi.com/api/json/utc/now";
    var content = JSON.stringify(body);
    var httpMethod = "get";
    var contentType = "application/json";
    // Get the current time - the pre-defined http object makes synchronous HTTP requests
    var currentDateTime = new Date(JSON.parse(http.request(url, httpMethod, content, contentType, headers)).currentDateTime);
    // Get the title's last reward heartbeat time
    var titleInternalData = server.GetTitleInternalData({}).Data;
    var titleLastRewardHeartbeat = titleInternalData.DailyRewardLastRewardHeartbeat;
    var rewardCycleLengthInMS = parseInt(titleInternalData.DailyRewardDelayTimeInMinutes) * 60 * 1000;
    var titleNextRewardDate = new Date(parseInt(titleLastRewardHeartbeat) + rewardCycleLengthInMS);
    rewardResult.titleNextRewardDate = titleNextRewardDate.toLocaleString();
    // Get the player's last reward claim time
    var userData = server.GetUserReadOnlyData({ PlayFabId: currentPlayerId, Keys: ["DailyRewardClaimed", "DailyRewardStreak"] });
    var playerLastRewardDate = userData.Data["DailyRewardClaimed"].Value;
    var playerRewardStreak = parseInt(userData.Data["DailyRewardStreak"].Value);
    rewardResult.playerRewardStreak = playerRewardStreak.toString();
    rewardResult.playerLastRewardDate = new Date(parseInt(playerLastRewardDate)).toDateString();
    if (playerRewardStreak > 5)
        rewardResult.playerLastReward = DAILY_REWARD_CYCLE[((playerRewardStreak - 5) % 3) + 3];
    else
        rewardResult.playerLastReward = DAILY_REWARD_CYCLE[playerRewardStreak];
    // Verify the player is eligible for a new daily reward
    if (playerLastRewardDate > titleLastRewardHeartbeat) {
        message = "The player " + currentPlayerId + " was NOT YET eligible for a new reward. Wait for the next title reward heartbeat";
        log.info(message);
        return {
            messageValue: message,
            playerRewardInfo: {
                playerRewardStreak: rewardResult.playerRewardStreak,
                playerLastRewardDate: rewardResult.playerLastRewardDate,
                playerLastReward: rewardResult.playerLastReward,
                titleNextRewardDate: rewardResult.titleNextRewardDate
            }
        };
    }
    else {
        message = "The player " + currentPlayerId + "IS ELIGIBLE for a new reward.";
        log.info(message);
    }
    // Check to see if the player has broken their streak, else increment
    if (currentDateTime.getTime() - parseInt(playerLastRewardDate) > rewardCycleLengthInMS) {
        playerRewardStreak = 0;
        log.info("The player " + currentPlayerId + " broke their streak. Resetting to 0");
    }
    else {
        playerRewardStreak++;
    }
    rewardResult.playerRewardStreak = playerRewardStreak.toString();
    //
    // Next check to see if the player is wrapping from 6 back to 4
    // rewardDay == 0 grants the day 1 bundle
    // rewardDay == 5 grants the day 6 bundle
    // rewardDay == 6 is adjusted back to 3 which grants the day 4 bundle
    //
    var rewardDay = playerRewardStreak;
    if (rewardDay > 5) {
        rewardDay = rewardDay - 5;
        rewardDay = rewardDay % 3;
        rewardDay = rewardDay + 3;
    }
    rewardResult.playerLastReward = DAILY_REWARD_CYCLE[rewardDay];
    var grantItemsRequest = {
        PlayFabId: currentPlayerId,
        CatalogVersion: "PMHackathonCatalog",
        ItemIds: [rewardResult.playerLastReward]
    };
    log.info("Granting reward[" + rewardDay + "] = " + rewardResult.playerLastReward + " to player " + currentPlayerId);
    var grantItemResult = server.GrantItemsToUser(grantItemsRequest);
    //server.ConsumeItem(grantItemResult[0].ItemInstanceId);
    // update player's info and the rewardResult struct if grant was successful
    server.UpdateUserReadOnlyData({
        PlayFabId: currentPlayerId,
        Data: {
            "DailyRewardClaimed": JSON.stringify(currentDateTime.getTime()),
            "DailyRewardStreak": JSON.stringify(playerRewardStreak)
        }
    });
    return {
        messageValue: message,
        playerRewardInfo: {
            playerRewardStreak: rewardResult.playerRewardStreak,
            playerLastRewardDate: currentDateTime.toDateString(),
            playerLastReward: rewardResult.playerLastReward,
            titleNextRewardDate: rewardResult.titleNextRewardDate
        }
    };
};
handlers["DailyRewardsTryClaimReward"] = DailyRewardsTryClaimReward;
// This is a Cloud Script function. "args" is set to the value of the "FunctionParameter" 
// parameter of the ExecuteCloudScript API.
// (https://api.playfab.com/Documentation/Client/method/ExecuteCloudScript)
// "context" contains additional information when the Cloud Script function is called from a PlayStream action.
var SpendingEventHelloWorld = function (args, context) {
    // The pre-defined "currentPlayerId" variable is initialized to the PlayFab ID of the player logged-in on the game client. 
    // Cloud Script handles authenticating the player automatically.
    var message = "Hello " + currentPlayerId + "!";
    // You can use the "log" object to write out debugging statements. It has
    // three functions corresponding to logging level: debug, info, and error. These functions
    // take a message string and an optional object.
    log.info(message);
    var inputValue = null;
    if (args && args.inputValue)
        inputValue = args.inputValue;
    log.debug("spendingeventhelloWorld:", { input: args.inputValue });
    // The value you return from a Cloud Script function is passed back 
    // to the game client in the ExecuteCloudScript API response, along with any log statements
    // and additional diagnostic information, such as any errors returned by API calls or external HTTP
    // requests. They are also included in the optional player_executed_cloudscript PlayStream event 
    // generated by the function execution.
    // (https://api.playfab.com/playstream/docs/PlayStreamEventModels/player/player_executed_cloudscript)
    return { messageValue: message };
};
handlers["SpendingEventHelloWorld"] = SpendingEventHelloWorld;
// This is a Cloud Script function. "args" is set to the value of the "FunctionParameter" 
// parameter of the ExecuteCloudScript API.
// (https://api.playfab.com/Documentation/Client/method/ExecuteCloudScript)
// "context" contains additional information when the Cloud Script function is called from a PlayStream action.
var GetFishingGameConfig = function (ars, context) {
    var titleData = server.GetTitleData({ Keys: ["FishingTournamentData", "FishingGameConfig"] }).Data;
    var baseGameConfig = JSON.parse(titleData["FishingGameConfig"]);
    var tournamentData = JSON.parse(titleData["FishingTournamentData"]);
    if (isActiveTournament()) {
        log.info("Tournament game config data returned", tournamentData.gameConfig);
        return tournamentData.gameConfig;
    }
    else {
        log.info("Base game config data returned", baseGameConfig);
        return baseGameConfig;
    }
};
var isActiveTournament = function () {
    var titleData = server.GetTitleData({ Keys: ["FishingTournamentData", "FishingGameConfig"] }).Data;
    var tournamentData = JSON.parse(titleData["FishingTournamentData"]);
    var curDate = Date.now();
    var startDate = Date.parse(tournamentData.startDate);
    var endDate = Date.parse(tournamentData.endDate);
    return (curDate >= startDate && curDate <= endDate);
};
var ProcessTournamentFish = function (args, context) {
    //log.debug("Arguments:", { args: args, context: context }); 
    // if tournament is going on
    if (isActiveTournament()) {
        var countTournamentFishCaught = context.playStreamEvent["StatisticValue"] - context.playStreamEvent["StatisticPreviousValue"];
        server.UpdatePlayerStatistics({ PlayFabId: currentPlayerId, Statistics: [{ StatisticName: "FishCaughtTournament", Value: countTournamentFishCaught }] });
        log.debug("Fish To Count", { FishCaught: countTournamentFishCaught });
    }
};
handlers["GetFishingGameConfig"] = GetFishingGameConfig;
handlers["ProcessTournamentFish"] = ProcessTournamentFish;
//# sourceMappingURL=combined-cloudScript.js.map